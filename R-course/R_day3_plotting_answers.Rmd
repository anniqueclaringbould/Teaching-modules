---
title: "R course day 3: Plotting"
author: "Niek de Klein, Annique Claringbould"
output: 
  html_document:
    toc: true # table of content true
    depth: 3  # upto three depths of headings (specified by #, ## and ###)
    number_sections: true  ## if you want number sections at each table header
    highlight: tango  # specifies the syntax highlighting style
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


<br><br><br>

# Introduction

You have already explored the **Iris** dataset by determining differences in petal and sepal size of different types of these plants. In this tutorial you will learn how to visualize these difference using different kinds of plots with an external package called **ggplot2**. 

**ggplot2** is an R package created by Hadley Wickham in 2005. It can highly improve the quality and aesthetic of your graphs. As you've seen in the last days, R also has some built-in plotting functions, but today we will be focusing on **ggplot2**.

Scroll through [http://www.r-graph-gallery.com/portfolio/ggplot2-package/](http://www.r-graph-gallery.com/portfolio/ggplot2-package/) to see some examples of the plots you can make. Clicking on a plot shows the code that was used to make it.
<br><br>

```{r, message=FALSE, warning=FALSE, eval=FALSE, echo=TRUE}
# if you haven't installed it yet, install ggplot2
install.packages('ggplot2')
```
<br>

First, we have to load the **ggplot2** package using the `library()` function. 
```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
library(ggplot2)
```
<br><br>

# Plotting

## Easy example
Now we have loaded the **ggplot2** library lots of new methods are available. The first function you always need when making a ggplot is `ggplot()`. Let's try the basic function `ggplot()` and `geom_point()` to generate a scatter plot.  

The first argument in `ggplot()` is the dataset you want to use to generate the plot, in this case we're using the **iris** dataset again. The second argument is the `aes()` or aesthetic function, where you can set which variables of the dataset are used for the available visual properties. In the case of this scatterplot we're only interested in the x and y position of each data point.

```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width))
```
<br>

Just running the command above will generate an empty plot. This is because **ggplot2** doesn't know what kind of plot you wish to make. The function `geom_point()` will tell **ggplot2** to make a scatterplot. Combining the two functions  `ggplot(...) + geom_point()` will result in a scatterplot:

```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width)) + 
  geom_point()
```
<br>

**Q1**: Make a scatterplot between the Petal Length and Petal Width. How many clusters do you see?
```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
#Question 1
#Code
ggplot(iris, aes(x=Petal.Length, y=Petal.Width)) + 
  geom_point()

#Answer
#There are two clusters visible, probably due to species
```
<br><br>

## Histrograms
One of the first things to check when you are visualy exploring a dataset is the distribution of its variables. A common way to do this is by plotting a histogram. With **ggplot** you can do this easily by using `geom_histogram()`. For instance we can look at the distribution of petal lengths with the following command:
```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
ggplot(iris, aes(x=Petal.Length)) + 
  geom_histogram()
```
<br>

As you can see, `aes()` function now only takes one argument (x) since we are only interested in the distribution of one variable.

The length of every bin is the number of observations within the range (width) of each bin. You can customize the width of each bin with the `binwidth` argument. This might be useful if the dataset contains many more observations:
```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
ggplot(iris, aes(x=Petal.Length)) + 
  geom_histogram(binwidth = 0.05)
```
<br>

**Q2** 

* Make a histogram of the Sepal length
* Use `binwidth = 0.05`
* By looking at  the plot: what sepal length is most prevalent?
```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
#Question 2
#Code
ggplot(iris, aes(x=Sepal.Length)) + 
  geom_histogram(binwidth = 0.05)

#Answer
#The most counted length (10 times) is exactly 5 cm
```
<br><br>

## Boxplots

A box plot is another quick way of examining one or more sets of data graphically. The box shows where the majority of the data points are located, the band in the box is the median and the whiskers shows the complete range of values.  Box plots may seem more primitive than a histogram but they do have some advantages. They take up less space and are therefore particularly useful for comparing distributions between several groups or sets of data.

Since the iris dataset includes different species we can use boxplots to compare the distribution of values between these groups.
<br>

**Q3**: 

* Make a boxplot of the Sepal length per species
* Use `+ geom_boxplot()`
* Specify that the aesthetic for x-axis are `Species`, and for y-axis the sepal width
* What species has the largest median sepal width?
```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
#Question 3
#Code
ggplot(iris, aes(x=Species, y=Sepal.Width)) + 
  geom_boxplot()

#Answer
#The largest mean sepal width is measured in the setosa iris flowers
```
<br><br>

## Saving plots

In **ggplot2** it is possible to add extra options to a plot by simply on top of the ```ggplot()``` function. Therefore it can be convenient to store the result of ```ggplot()``` inside a variable. For example:
```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
plot1 <- ggplot(iris, aes(x=Species, y=Sepal.Width))
plot2 <- plot1 + geom_boxplot()
plot3 <- plot2 + theme_bw()
```
<br>
Notice that this won't generate any graphical output. Like with any assignment, this will not immediately print the content of the variable `plot3`. 

**Q4** Consecutively type `plot1`, `plot2`, `plot3`. What is added in each plot?
```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
#Question 4
#Code
plot1
plot2 
plot3

#Answer
#First plot: empty outline
#Second plot: boxplot of Sepal Width
#Thirs plot: different background
```
<br>

**Q5**

* Make a boxplot of sepal length
* Save it under the name `sepal.length.boxplot`
```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
#Question 5
#Code
plot1 <- ggplot(iris, aes(x=Species, y=Sepal.Length))
sepal.length.boxplot <- plot1 + geom_boxplot()
sepal.length.boxplot
```

<br><br>

# Improving plots

## Adding shapes

Now we have stored the plot, we can add shapes to the plot by adding to the `sepal.length.boxplot` variable. The functions `geom_hline()` and `geom_vline()` are used to add horizontal and vertical lines to a plot. For instance we can draw a horizontal line over the plot to indicate what the mean is of sepal lengths for the complete dataset. The only argument these functions need is the interception of the x- or y-axis.

**Q6**

* Calculate the mean Sepal length across all species
* Save this mean as `sepal.length.mean`
* Add the mean as a line to sepal.length.boxplot using `geom_hline(yintercept = sepal.length.mean)`
* Make the line stand out by adding `color = "red"` within the brackets of `geom_hline()`
* Do you think the mean is representative of all species? Does it overlap with the 'whiskers' of the boxplot?

```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
#Question 6
#Code

# First calculate the mean
sepal.length.mean <- mean(iris$Sepal.Length)

# Add a horizontal line to the plot
sepal.length.boxplot + 
  geom_hline(yintercept = sepal.length.mean, color = "red")

#Answer
#No, the mean across all species does not overlap with the whiskers of setosa
#The mean is almost equal to the mean for versicolor but clearly not for
#setosa and virginica
```
<br><br>

## Adding text

Previously we have determined if there was a significant differences in petal lengths using a t-test. The p-value yielded by this test is very informative and can be added to plot easily. 

**Q7**

* Run a t-test to determine the difference in means of sepal length between *Iris virginica* and *Iris versicolor*
* Store the p-value in a variable called `t.test.p.value`
* What is the p-value?
```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
#Question 7
#Code
t.test.p.value <- t.test(iris[iris$Species == 'virginica',]$Sepal.Length, iris[iris$Species == 'versicolor',]$Sepal.Length)$p.value
t.test.p.value

#Answer
#the p-value is 1.866144e-07
```
<br>

To annotate the boxplot with the p-value of the t-test, we can use the `annotate()` function. We need to provide what type of annotation we want, the x and y position and the actual text of the annotation. But first we have to format the label properly.

**Q8**

* Round the 3 p-value to 3 significant digits using `signif()` and save the new value as `t.test.p.value` again
* Create a label using `paste("p-value =", t.test.p.value)`
* Save the label as `p.value.label`
* Add the annotation to the boxplot:
  `+ annotate("text", x = 1.5, y = 8, label = p.value.label)`
* Adjust the position of the `p.value.label` to the right lower
  *Hint*: play around with the values of x and y in `annotate()` until the label is placed where you like it
```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
#Question 8
#Code
# Round the p-value to 3 digits
t.test.p.value <- signif(t.test.p.value, 3)
# Create a string by pasting "p-value =" and the p-value
p.value.label <- paste("p-value =", t.test.p.value)
# Plot the boxplot + the annotation
sepal.length.boxplot + annotate("text", x = 3, y = 1, label = p.value.label)
```
<br><br>

## Adding layers

While **ggplot2** makes good plots right out off the box, they are also highly adjustable.

Basically every line, colour, shape or text in the plot can be adjusted. Let's enhance our boxplot a bit by adding the actual data points as dots by adding `geom_point()`.

```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
sepal.length.boxplot + 
  geom_point()
```
<br>

Because we are plotting in one dimension, the above statement will draw all dots on a single line. Since some measurements might overlap it is a good idea to add some random noise to the 'x' position of each point. We can adjust the x position by using the `position` argument of the `geom_point()` function. The random noise can be added using `"jitter"` as value. To move the points a bit to the background we can also adjust the size, color and transparency using the `size`, `color`, `alpha` arguments.
<br>

**Q9**

* Make a new boxplot of Sepal length called `sepal.length.boxplot.jitter`
* In the brackets of `geom_point()`, add the following:
  `position = "jitter"`
  `size = 1`
  `alpha = 0.5`
  `color = c("COLORNAME")`
* Fill in a color you like, mabye `"blue"` or `"cyan"`
* Check out all kinds of color names in R in this [overview] (http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf)
* If you make the same plot a few times in a row, are they exactly the same? Why (not)?

```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
#Question 9
#Code
sepal.length.boxplot.jitter <- sepal.length.boxplot + 
                        geom_point(position = "jitter", size=1, color=c("blue"), alpha=0.5)
sepal.length.boxplot.jitter

#Answer
#The plots will change ever so slightly because there is a random component to the jitter function that moves the dots around a little differently every time.
```
<br><br>


## Changing axis labels
Sometimes it is useful to change the sizes of the labels. For instance when you want to use your plots for a presentation or for a poster you want to increase the font size of the labels, so that the people in the back of the room also have an idea what you are talking about. We can do this by using the `theme()` function. Type `?theme` in your console to see what arguments can be used when calling this function.

As you can see there are a lot of arguments available, we can use the `axis.title` argument to adjust both axes at once. To change them separately we could use `axis.title.x` and `axis.title.y`:

```{r, message=FALSE, warning=FALSE, eval=FALSE, echo=TRUE}
sepal.length.boxplot + 
  theme(axis.title = element_text(size = 15))
```
<br>

The text of the label on the y axis "Sepal.Length" is not despriptive enough. All the measurements of the iris dataset are in centimeters, so we should add the unit here. To change the text of the y label we can use the `ylab()` function and add it to plot like we are used to. 

**Q10**

* Start with your saves `sepal.length.boxplot.jitter` 
* Change the axis labels to be larger (see example code above)
* Change the y-axis label text to include the units: `"Sepal length (cm)"`
* Store the new plot as ```sepal.length.boxplot.labels``` 
```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
#Question 10
#Code
sepal.length.boxplot.labels <- sepal.length.boxplot.jitter + 
                        theme(axis.title = element_text(size = 15)) + 
                        ylab("Sepal length (cm)")
sepal.length.boxplot.labels
```
<br>

The size of the text of the species beneath the boxplots can also be increased by adding more arguments to the `theme()` function. The argument we need to change the text of axis is `axis.text.x`.
<br>

**Q11**

* Start with your saves `sepal.length.boxplot.labels` 
* Change the x-axis species text size using `theme(axis.text.x = element_text(size = 3))`
* What's wrong?
* Adjust the mistake and save the result as `sepal.length.boxplot.sizes`
```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
#Question 11
#Code
sepal.length.boxplot.labels + theme(axis.text.x = element_text(size = 3))

sepal.length.boxplot.sizes <- sepal.length.boxplot.labels + 
                        theme(axis.text.x = element_text(size = 13))
sepal.length.boxplot.sizes

#Answer
#The labels become way too small with size = 3
```
<br>
To make a beter distinction between the two boxplot we could also color the boxes:
```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
sepal.length.boxplot.sizes + 
  geom_boxplot(aes(fill=Species))
```
<br>

As you can see the boxplot is drawn on top of `geom_point`, this is because we have added the boxplot as another layer on top of the previous plot.
<br>

**Q12**:

* Recreate the coloured boxplot above so that the points lay on top of the boxplot
* Call the new boxplot `sepal.length.boxplot.new`
* Change the colour of the dots if you do not like the combination with the box plot colours

```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
#Question 12
#Code
sepal.length.boxplot.new <- ggplot(iris, aes(x=Species, y=Sepal.Length,fill=Species)) + 
                        geom_boxplot() + 
                        geom_point(position = "jitter", size=1, color=c("navy"), alpha=0.5)+ 
                        theme(axis.title = element_text(size = 15),
                              axis.text.x = element_text(size = 13)) + 
                        ylab("Sepal length (cm)")
#sepal.length.boxplot.new
```
<br>

Not everyone likes the grey background. An easy way to remove these (and to make the plot look less like a default ggplot) is to add `theme_bw()`:

```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
sepal.length.boxplot.new + 
  theme_bw()
```
<br><br>

# Grouped plots

## Melting data

There are many situations where data is presented in a format that is not ready to dive straight to exploratory data analysis or to use a desired statistical method. The **reshape2** package for R provides useful functionality to avoid having to hack data around in a spreadsheet prior to import into R. More recently, it has become the norm to use the **dplyr** package for reformatting data, and although I highly recommend that you use **dplyr** if you are going to work more in R, it does require a little getting used to. Therefore, we will stick to **reshape2** for this tutorial.

The `melt()` function takes data formatted as a matrix with a set of columns, like our data, and formats it into a single column. For some application of GGplot we need this format. To make use of the function we need to specify a data frame, the id variables (which will be left at their settings) and the measured variables (columns of data) to be stacked. The default assumption on measured variables is that it is all columns which are not specified as id variables.

Load the **reshape2** library, so we can use the `melt()` function, and print the `head()` of **iris** again.
```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=FALSE}
library(reshape2)
head(iris)
```
<br>

Our id variable is `Species`, so we use this the value of the `id.vars` argument of the melt function. All the other columns are variables we would like to use and therefore we do not have to specify the `measure.vars` argument. 
```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
iris.melt <- melt(iris, id.vars = "Species")
```
<br>

**Q13**

* Explore the new reformatted data frame `iris.melt` using `head()`, `dim()` and `str()`
* What does each of the columns indicate?
* How is this different from the initial dataset?

```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
#Question 13
#Code
head(iris.melt)
str(iris.melt)
dim(iris.melt)

#Answer
#The first column shows species
#The second column shows the four variables (sepal length, sepal width, petal length, petal width)
#The third column includes the actual measurement in cm
```
<br><br>

## Facets

Now that we have melted our data we can use the `facet_wrap()` and `facet_grid()` functions. The facet approach partitions a plot into a matrix of panels. Each panel shows a different subset of the data.

We can plot the molten data frame by plotting the distribution of every variable as boxplots:
```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
ggplot(iris.melt, aes(x=variable, y=value)) + 
  geom_boxplot()
```
<br>

As you can see, these boxplots combine the values of all three iris species for the width and length of sepal and patel.

If we want to plot the distribution of every species separately we can use the `facet_grid()` function. You have to specify a formula with the rows (of the plot matrix) on the left hand side of `~` and the columns (of the plot matrix) on the right hand side of `~`: `facet_grid(ROWVARIABLE~COLUMNVARIABLE)`. You can keep one of the two variables empty as well by adding `.`:

```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
ggplot(iris.melt, aes(x=variable, y=value)) + 
  geom_boxplot() + 
  facet_grid(Species~.)
```
<br>

**Q14**

* Make the same plot as above, but this time put the species as row variable
* What changes?
* Which plot makes it easier to compare across species?
```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
#Question 14
#Code
ggplot(iris.melt, aes(x=variable, y=value)) + 
  geom_boxplot() + 
  facet_grid(.~Species)

#Answer
#The plot with species as row variable has the species on top 
#and it's easier to horizontally compare e.g. sepal length across species
```
<br>

It's probably more informative to group the variables instead of the species so you can compare the sepal lengths across species.

**Q15** Use the `facet_grid()` function so that that the boxplots are grouped by the measured variables. The plot should look like this:

```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
#Question 15
#Code
ggplot(iris.melt, aes(x=Species, y=value)) + geom_boxplot() + facet_grid(~variable)
```
<br><br>

## Violin plots

A violin plot is another method of plotting numerical data. The violin plot is similar to box plots, except that they also show the probability density of the data at different values. A violin plot is more informative than a plain boxplot: while a boxplot only shows summary statistics: mean/median, interquartile ranges and outliers, the violin plot shows the full distribution of the data.
We can make violin plots using the `geom_violin()` function from **ggplot2**.
<br>

**Q16**

* Use the `geom_violin()` function to create a similar plot like the last boxplot (grouped by the measured variables)
* Color the boxes by species and draw actual data points on top of the violin plot 
* Add `+ theme(axis.text.x=element_text(angle=45, hjust=1))` to rotate the x-axis labels so they don't overlap
* The final plot should look like below
* What do you notice in the distribution of the petal length across the three species?

```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
#Question 16
#Code
ggplot(iris.melt, aes(x=Species, y=value, fill=Species)) + 
  geom_violin() + 
  facet_grid(~variable) + 
  geom_point(position = "jitter", alpha=0.5, size=0.8) + 
  theme_bw() +
  theme(axis.text.x=element_text(angle=45, hjust=1))

#Answer
#The petal length of sentosa has a very small range, and almost all petals are ~1.5cm long
#while this is much more variable for the other two species
```
<br><br>

# Using plots to find anomalies

## Coloring points above a threshold

Sometimes you want to quickly see which points are above or below a certain threshold. Coloring these points can be done by first creating a vector with which points you want to color.

You can use the function `ifelse()` to make a vector of outliers vs. non-outliers. `ifelse()` is a function to determine the outcome depending on a condition. 

The first argument in the function is what you want to evaluate.
For example: for every value in iris$Sepal.Length: is it higher than 7.6 (True) or lower than 7.6 (False)?

The second parameter is the value that it should return if True

The third parameter is the value it should return if False

Here is the example we described:
```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
outlier <- ifelse(iris$Sepal.Length > 7.6, "Outlier", "Non-outlier")
iris$Sepal.Length
outlier
```
<br>

The outlier vector can then be given as a vector to the color parameter. Using `geom_text()` we also add a label to those points.
<br>

**Q17**

* Run the code below
* Do you think this cut-off really identifies outliers?

```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width, color=outlier)) +
  geom_point() +
  geom_text(aes(label = Sepal.Width), data = iris[iris$Sepal.Length>7.6,], color="black")
```
```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
#Question 17
#Code
ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width, color=outlier)) +
  geom_point() +
  geom_text(aes(label = Sepal.Width), data = iris[iris$Sepal.Length>7.6,], color="black")

#Answer
#No, these points fit within the distribution of all sepal width values and they should not be marked as outliers.
```
<br><br>

# Simpsons' paradox

One great way of showing the power of good visualization is Simpsons' paradox. 

Look again at the Iris correlations using `cor(iris[1:4])` and specifically look at the correlation between sepal length and width. As we discussed yesterday, epal width is negatively correlated with sepal length when correlating for all species together, but when correlating using the separate species they are all positive.

**Q18**

* Plot the species sepal length and width using **ggplot2** 
* In aesthetics, make x the sepal length and y the sepal width 
* Plot the best fitting linear model line by adding `+ geom_smooth(method = "lm")`
* What is the direction of the line? Is that in line with the negative correlation coefficient?

```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
#Question 18
#Code
ggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width)) + 
              geom_point() + 
              geom_smooth(method = "lm")

#Answer
#The best fitting line is negative, exactly in line with the correlation coefficient
```
<br>

**Q19** 

* Redo the plot from **Q18** but use `facet_grid()` to split for each species 
* Explain the opposite correlation
* Add `scales = "free_x"` as parameter to the `facet_grid()` function
* What is the difference before and after adding this?

```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE}
#Question 19
#Code
ggplot(data = iris, aes(Sepal.Length, Sepal.Width)) + 
              geom_point() + 
              facet_grid(. ~ Species) + 
              geom_smooth(method = "lm")

ggplot(data = iris, aes(Sepal.Length, Sepal.Width)) + 
              geom_point() + 
              facet_grid(. ~ Species, scales = "free_x") + 
              geom_smooth(method = "lm")

#Answer
#The correlation is positive within each species, but negative when combining all
#This phenomenon is called the Simpsons' paradox
#Adding the free scales means that the three plots do not have to adhere to the same x limits
```
<br><br>

# Saving plots to file
Finally, when you are finished with your plots you will want to save them to a file so that you can add them to your presentation or poster. When using `ggplot()` the easiest way to save is `ggsave()`:

```{r, message=FALSE, warning=FALSE, eval=FALSE, echo=TRUE}
plot1 <- ggplot(data = iris, aes(Sepal.Length, Sepal.Width)) +
  geom_point()

# Running ggsave() will save the last plot you made
ggsave('filename.png')

# The file type is based on the extension you use.
ggsave('filename.pdf')
```
<br>

When making figures for posters or presentations, be sure to only use either eps or pdf as these do not lose quality when resizing (read https://thepoliticalmethodologist.com/2013/11/25/making-high-resolution-graphics-for-academic-publishing/ if you want to know more).

You can save a specific plot stored in a variable by adding the parameter `plot=NAME`.
In the example below, you are saving `plot1` instead of `plot2`, which would be the case if you didn't specify that the plot you wanted to save now was `plot=plot1`.
```{r, message=FALSE, warning=FALSE, eval=FALSE, echo=TRUE}
plot2 <- ggplot(data = iris, aes(Sepal.Length, Sepal.Width)) +
            geom_boxplot()

ggsave('filename.pdf', plot=plot1)
```
<br>

You will often want to change the width, size and resolution of the plot depending on its use. For presentations when using one figure per slide you want it a bit wider than high, so you can add width and height. For posters you will probably want to use 300 dpi (dots per inch) as your resolution to ensure the plot looks great when printed at high quality.

```{r, message=FALSE, warning=FALSE, eval=FALSE, echo=TRUE}
ggsave('filename.pdf', plot=plot1, dpi=300, width=12, height=8)
```

**Q20**

* Save the last plot you made in **Q19** as a .pdf file
* Use a height of 10 and width of 15
* Run the following two commands:
* Repeat the last command for some more happiness :)

```{r, message=FALSE, warning=FALSE, eval=FALSE, echo=TRUE}
library(praise)
praise()
```